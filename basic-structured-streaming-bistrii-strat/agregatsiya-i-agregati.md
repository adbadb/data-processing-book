# Агрегация и агрегаты

Самый частый кейс для RealTime-приложений - это возможность выводить на табло обновляемые в фоновом режиме некоторые агрегаты: скользящие средние, нарастающие итоги \(суммы, количества\), максимальный и минимальный элементы временного ряда.

Для этого существует специальный режим агрегации **CompleteMode.**

В этом режиме мы и запустим вывод на консоль.

```scala
    val writer = result.writeStream
      .trigger(ProcessingTime(3000))
      .outputMode(OutputMode.Complete()) // можно передать и строку "complete"
      .format("console")
      .start()
```

На основе примера из главы "[JOIN для бедных](https://zaleslaw.gitbooks.io/data-processing-book/content/basic-structured-streaming-bistrii-strat/join-dlya-bednih.html)" строим агрегацию вдоль каждой страны, выводя нарастающую от раза к разу сумму ряда value:

```scala
    val join = stream.selectExpr("CAST(key AS STRING)", "CAST(value AS STRING)")
      .selectExpr("CAST(key as STRING)", "CAST(value AS INT)")
      .as[(String, String)]
      .join(dictionary, "key")

    val result = join.select($"country", $"value")
      .groupBy($"country")
      .sum("value")
```

или можно посчитать количество записей, приходящихся на каждую страну:

```scala
    val result = join.select($"country", $"value")
      .groupBy($"country")
      .count()
```

Весьма обширным получается DAG - первая часть нам знакома по предыдущей главе.

![](/assets/DAG_group_by_1.jpg)



Кроме того, что нам нужно провести предагрегацию на своей стороне, нам необходимо

* восстановить предыдущее накопленное состояние
* объединить новые результаты с ним
* сохранить полученные результаты для последущих инкрементальных джоб

Все это можно увидеть ниже.

![](/assets/DAG_group_by_2.jpg)

Ну и на закуску как обычно планы, в которых можно раглядеть и временные директории, куда сохранялось состояние между запусками инкрементальных джоб, и подробную информацию о функциях объединения \(полезно, если будете пытаться отладить\).

![](/assets/DAG_group_by_3.jpg)



P.S. Если же очень сильно хочется получать сырые данные, из которых получаются агрегаты в режиме **AppendMode, **то без магии Watermark и оконных функций не обойтись.



